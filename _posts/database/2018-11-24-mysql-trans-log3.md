---
layout: post
title: MySQL复制原理详解(转)
tags:
- database
categories: database
description:  MySQL复制原理详解
---


MySQL作为一个开源的数据库，有着广泛的应用。本文主要讲述了mysql复制的原理，以及异步复制、同步复制和并行复制。



<!-- more -->

## 1. MySQL复制的原理
MySQL有两种复制原理：基于行的复制和基于语句的复制。最早出现的是基于语句的复制，而基于行的复制方式在5.1版本中才被引入。这两种方式都是通过在主库上记录二进制日志(binlog)，在备库上重放日志的方式来实现异步的数据复制。这意味着在同一时间点备库上的数据可能和主库不一致，并且无法保证主库备库之间的延迟。

### 1.1 基于语句的复制
基于语句的复制模式下，主库会记录那些造成数据更改的查询，当备库读取并重放这些事件时，实际上只把主库上执行过的SQL再执行一遍。

1）**优点**

最明显的好处是实现相当简单。理论上讲，简单地记录和执行这些语句，能够让备库保持同步。另外的好处是binlog日志里的事件更加紧凑，所以相对而言，基于语句的模式不会使用太多带宽。一条更新好几兆数据的语句在二进制日志里可能只占用几十字节。

2）**缺点**

有些数据更新语句，可能依赖其他因素。例如，同一条SQL在主库和备库上执行的时间可能稍微或很不同，因此在传输的binlog日志中，除了查询语句，还包括一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法备正确复制的SQL。例如，使用CURRENT_USER()函数语句。 存储过程和触发器在使用基于语句的复制模式时也可能存在问题。另外一个问题是更新必须是串行的，这需要更多的锁，并且不是所有的存储引擎都支持这种复制模式。


### 1.2 基于行的复制
MySQL 5.1开始支持基于行的复制，这种方式将实际数据记录在二进制日志中，跟其他数据库的实现比较像。

1） **优点**

最大的好处是可以正确的复制每一行，一些语句可以被更加有效地复制。由于无需重放更新主库数据的查询，使用基于行的复制模式能够更加高效地复制数据。重放一些查询的代价会很高。例如，下面有一个查询将数据从一个大表中汇总到小表：
{% highlight string %}
mysql> INSERT INTO summary_table(col1,col2,sum_col3)

         ->SELECT col1,col2,sum(col3) from enormous_table GROUP BY col1,col2;
{% endhighlight %}

2) **缺点**

但是另外一方面，下面这条语句使用基于语句的复制方式代价会小很多：
{% highlight string %}
mysql> UPDATE enormous_table SET col1 =0 ;
{% endhighlight %}

由于这条语句做了全表更新，使用基于行的复制开销会大很多，因为每一行的数据都会被记录到二进制日志中，这使得二进制日志事件非常庞大。另外由于语句并没有在日志里记录，因此无法判断执行了哪些SQL，除了需要知道行的变化外，这在很多情况下很重要。执行基于行的过程像一个黑盒子，你无法知道服务器正在做什么。


由于没有哪一种模式对所有情况都是完善的，MySQL能够在这两种复制模式间动态切换。默认情况下使用的是基于语句的复制方式，但是如果发现语句无法被正确地复制，就切换成基于行的复制模式。还可以根据需要来设置会话级别的变量binlog_format，控制二进制日志格式。

## 2.异步复制过程

总体来说，复制有3个步骤：

1） 主服务器把数据更改记录到二进制日志中

2） 从服务器把主服务器的二进制日志拷贝到自己的中继日志中；

3） 从服务器重放中继日志中的事件，把更改应用到自己的数据上；

这只是一个概述，每一个步骤都很复杂。下图更清晰地描述了复制地过程：


![db-mysql-dolog](https://ivanzz1001.github.io/records/assets/img/db/db_async_replication.png)


第一步：在主服务器上记录二进制日志。在每个更新数据的事务完成之前，主服务器都会将数据更改记录到二进制日志中。即使事务在执行期间是交错的，MySQL也会串行地将事务写入到二进制日志中。在把事件写入二进制日志之后，主服务器告诉存储引擎提交事务；

第二步：从服务器把主服务器的二进制日志拷贝到自己地硬盘上，进入所谓的“中继日志”中。首先，它启动一个工作线程，叫IO线程，这个IO线程开启一个普通的客户端连接，然后启动一个特殊的二进制日志转储进程（它没有响应的SQL命令）。这个转储进程从主服务器的二进制日志中读取数据，它不会对事件进行轮询。如果其跟上了主服务器，就会进入休眠状态并等待有新的事件发生时主服务器发出的信号。IO线程把数据写入从服务器的中继日志中。

第三步：SQL线程读取中继日志，并且重放其中的事件，然后更新从服务器的数据。由于这个线程能跟上IO线程，中继日志通常在操作系统的缓存中，所以中继日志的开销很低。SQL线程执行事件也可以被写入从服务器自己的二进制日志中，它对于有些场景很实用。


## 3. 半同步复制

一般情况下，异步复制就已经足够应付了，但由于是异步复制，备库极有可能落后于主库，特别是极端情况下，我们无法保证主备数据是严格一致的。比如，当用户发起commit命令时，master并不关心slave的执行状态，执行成功后，立即返回给用户。试想下，若一个事务提交后，master成功返回给用户后crash，这个事务的binlog还没来的及传递到slave，那么slave相对于master而言就少了一个事务，此时主备就不一致了。对于要求强一致的业务是不可接受的，半同步复制就是为了解决数据一致性而产生的。

为什么叫半同步复制？先说说同步复制，所谓同步复制就是一个事务在master和slave都执行后，才返回给用户执行成功。这里核心是说master和slave要么都执行，要么都不执行，涉及到2PC(2 Phase Commit)。而MySQL只实现了本地redo log和binlog的2PC，但并没有实现Master和Slave的2PC，所以不是严格意义上的同步复制。而MySQL半同步复制不要求slave执行，而仅仅是接收到日志后，就通知master可以返回了。这里关键点是slave接收日志后是否执行，若执行后才通知master则是同步复制；若仅仅是接收日志成功，则是半同步复制。对于MySQL而言，我们谈到的日志都是binlog，对于其他的关系型数据库可能是redo log或其他日志。


半同步复制如何实现？半同步复制实现的关键点是master对于事务提交过程特殊处理。目前实现半同步复制主要有两种模式：```AFTER_SYNC```模式和```AFTER_COMMIT```模式。两种方式的主要区别在于是否在存储引擎提交后等待slave的ACK。

### 3.1 AFTER_COMMIT模式
我们先来看看AFTER_COMMIT模式，如下图，Start和End分别表示用户发起commit命令和master返回给用户的时间点，中间部分就是整个commit过程master和slave坐的事情：

![db-mysql-dolog](https://ivanzz1001.github.io/records/assets/img/db/db_semi_rep1.png)

master提交时，会首先将该事务的redo log刷入磁盘，然后将事务的binlog刷入磁盘（这里其实还涉及到两阶段提交的问题，暂不展开讲），然后进入innodb commit流程，这个步骤主要是释放锁，标记事务为提交状态（其他用户可以看到该事务的更新），这个过程完成后，等待slave发送的ACK消息，等到slave的响应后，master才成功返回给用户。看到图中红色虚线部分，这段是master和slave的同步逻辑，是master-slave一致性的保证。


半同步复制是否能保证不丢数据？我们通过几种场景来简单分析下：

1） **场景1**

假设master第1、2步执行成功后，binlog还没来得及传递给slave，此时master挂了，slave作为新的master提供服务，那么备库比主库少一个事务(因为主库的redo log和binlog 已经落盘），但是不影响用户，对于用户而言，这个事务没有成功返回，那么提交与否，用户都可以接受，用户一定会进行异常捕获而重试。

2）**场景2**

假设第3步innodb commit执行成功后，




半同步复制是否能保证不丢数据？我们通过几种场景来简单分析下。第一种情况：假设Master第1，2步执行成功后，binlog还没来得及传递给Slave，此时Master挂了，Slave作为新Master提供服务，那么备库比主库要少一个事务(因为主库的redo 和binlog已经落盘)，但是不影响用户，对于用户而言，这个事务没有成功返回，那么提交与否，用户都可以接受，用户一定会进行异常捕获而重试。第二种情况，假设第3步innodb commit执行成功后，binlog还没来得及传递给Slave，此时Master挂了，此时与第一种情况一样，备库比主库少一个事务，但是其他用户在3执行完后，可以看到该事务的更新，而切换到备库后，却发现再次读这个更新又没了，这个就发生了“幻读”，如果其他事务依赖于这个更新，则会对业务逻辑产生影响。当然这仅仅是极端情况。












<br />
<br />
**[参看]**:

1. [简单谈谈MySQL的半同步复制](http://www.manongjc.com/article/147913.html)

2. [MySQL 复制原理详解](https://cloud.tencent.com/developer/article/1005270)

3. [MySQL半同步复制](https://www.cnblogs.com/ivictor/p/5735580.html)

4. [MySQL的存储引擎与日志说明](https://www.cnblogs.com/clsn/p/8087678.html#auto-id-22)

<br />
<br />
<br />

