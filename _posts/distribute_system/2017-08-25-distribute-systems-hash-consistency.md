---
layout: post
title: 分布式一致性哈希算法原理
tags:
- 分布式系统
categories: distribute-systems
description: 分布式系统理论
---

本文我们介绍一下分布式一致性哈希算法的基本原理。

<!-- more -->


## 1. 分布式算法

在做服务器负载均衡的时候，可供选择的负载均衡的算法有很多，包括： 轮询算法（Round Robin)、哈希算法（Hash）、最少连接算法（Least Connection）、响应速度算法(Response Time)、加权法(Weighted)等。其中哈希算法是最为常用的算法。

典型的应用场景是： 有N台服务器提供缓存服务，需要对服务器进行负载均衡，将请求平均分发到每台服务器上，每台机器负责1/N的服务。

常用的算法是对hash结果取余数(hash() mod N): 对机器编号从0到N-1，按照自定义的hash()算法，对每个请求的hash()值按N取模，得到```余数i```，然后将请求分发到编号为```i```的机器。但这样的算法存在致命问题，如果某一台机器宕机，那么应该落在该机器上的请求就无法得到正确的处理，这时需要将宕掉的服务器从算法中移除，此时会有```(N-1)/N```的服务器的缓存数据需要重新计算；如果新增一台机器，会有```N/(N+1)```的服务器的缓存数据需要进行重新计算。对于系统而言，这通常是不可接受的颠簸（因为这意味着大量缓存的失效或者数据需要转移）。那么，如何设计一个负载均衡策略，使得受到影响的请求尽可能的少呢？

在Memcached、Key-Value Store、Bittorrent DHT、LVS中都采用了Consistent Hashing算法，可以说Consistent Hashing是分布式系统负载均衡的首选算法。


## 2. 分布式缓存问题
在大型web应用中，缓存可以算是当今的一个标准开发配置了。在大规模的缓存应用中，应运而生了分布式缓存系统。分布式缓存系统的基本原理，大家也有所耳闻。key-value如何均匀的分散到集群中？ 说到此，最常规的方式莫过于hash取模的方式。比如集群中可用机器数量为```N```，那么key值为```K```的数据请求很简单的应该路由到```hash(K) mod N```对应的机器。的确，这种结构是简单的，也是实用的。但是在一些高速发展的Web系统中，这样的解决方案仍有些缺陷。随着系统访问压力的增长，缓存系统不得不通过增加机器节点的方式提高集群的响应速度和数据承载量。增加机器意味着按照hash取模的方式，在增加机器节点的这一时刻，大量的缓存命不中，缓存数据需要重新建立，甚至是进行整体的缓存数据迁移，瞬间会给DB带来极高的系统负载，甚至导致DB服务器宕机。那么就没有办法解决hash取模的方式带来的诟病吗？


假设我们有一个网站，最近发现随着流量的增加，服务器压力越来越大，之前直接读写数据库的方式不太给力了，于是我们想引入```Memcached```作为缓存机制。现在我们一共有三台机器可以作为Memcached服务器，如下图所示：


![hc-memcached](https://ivanzz1001.github.io/records/assets/img/distribute/hc_memcached_system.png)



 


<br />
<br />

**[参看]**

1. []()

2. []()

<br />
<br />
<br />


