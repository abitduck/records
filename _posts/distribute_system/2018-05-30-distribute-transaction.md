---
layout: post
title: 分布式事务解决方案(转)
tags:
- 分布式系统
categories: distribute-systems
description: 分布式事务解决方案
---

本章介绍一下分布式事务方面的一些内容。

<!-- more -->

## 1. 基础知识

1） **事务**

事务由一组操作构成，我们希望这组操作能够全部正确执行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务中的所有操作，要么全都正确执行，要么全都不要执行。

2） **事务的四大特性ACID**

* 原子性： 事务是一个不可分割的执行单元，事务中的所有操作那么全部执行，要么全部不执行；

* 隔离性：事务的执行是相互独立的，它们不会相互干扰，一个事务不会看到另一个正在运行过程中的事务的数据；

* 持久性： 持久性要求，一个事务完成之后，事务的执行结果必须是持久化保存的。即使数据库发生崩溃，在数据库恢复后事务提交的结果仍然不会丢失；

* 一致性： 事务在开始前和结束后，数据库的完整性约束没有被破坏。

3） **脏读、幻读、虚读及不可重复读**

* 脏读：如果一个事务中对数据进行了更新，但事务还没有提交，另一个事务可以“看到”该事务没有提交的更新结果，这样造成的问题就是，如果第一个事务回滚，那么，第二个事务在此之前所“看到”的数据就是一笔脏数据。

不可重复读：包括幻读和虚读两种情况

* 幻读：事务1在两次查询的过程中，事务2对该表进行了插入、删除操作，从而事务1第二次查询的结果发生了变化。

* 虚读：在事务1两次读取同一记录的过程中，事务2对该记录进行了修改，从而事务1第二次读到了不一样的记录。

4） **数据库的四种隔离级别**

* 读未提交(read uncommitted): 在该级别下，一个事务对一行数据修改的过程中，不允许另一个事务对该行数据进行修改，但是允许另一个事务对该行数据读。因此在本级别下，不会出现更新丢失，但会出现脏读，不可重复读。

* 读提交(Read Committed): 在该隔离级别下，不允许两个未提交的事务之间并行执行，但它允许在一个事务执行的过程中，另外一个事务得到执行并提交。这样，会出现一种情况，第一个事务前后两次select出来的某行数据，值可能不一样。值改变的原因是，穿插执行的事务2对该行数据进行了update操作。在同一个事务中，两次select出来的值不相同的问题称为不可重复读问题。要解决不可重复读问题，需要把数据的隔离级别设置为可重复读。

* 重复读(Repeatable read): 在该隔离级别下，在一个事务使用某行数据的过程中，不允许别的事务再对该行数据进行操作。可重复读应该是给数据库的行加上了锁。这种隔离级别下，依旧允许别的事务在该表中插入和删除数据，于是就会出现，在事务1执行的过程中，如果先后两次select出符合某个条件的行，如果在这两次select过程中另一个事务得到了执行，insert或者delete了某些行，就会出现先后两次select出来的符合同一条件的结果不一样，第一次select好像出现了幻觉一样，因此这个问题也被称为```幻读```。要解决幻读问题，需要将数据库的隔离级别设置为串行化。

* 序列化（serializable）：该级别要求所有事务都必须串行执行，因此能避免一切因并发引起的问题，但效率很低。

>注： mysql默认的隔离级别是重复读级别，oracle是读提交

5) **乐观锁和悲观锁**

* 乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。

* 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

## 2. mysql如何保证持久性和原子性

在数据库系统中，既有存放数据的文件，也有存放日志的文件。日志在内存中也是有缓存Log buffer，也有磁盘文件log file。

MySQL中的日志文件，有这么两种与事务有关：undo日志与redo日志。

### 2.1 undo日志
数据库事务具备原子性(atomicity)，如果事务执行失败，需要把数据回滚。事务同时还具备持久性(durability)，事务对数据所做的变更需要保存到硬盘，不能因为故障而丢失。

事务的原子性可以利用undo日志来实现。

undo log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到undo log，然后进行数据的修改。如果出现了错误或者用户执行了```rollback```语句，系统可以利用undo log中的备份将数据恢复到事务开始之前的状态。

数据库写入数据到磁盘之前，会把**数据先缓存到内存**中，事务提交时才会写入磁盘中。用undo log实现原子性和持久化的事务的简化过程如下：

<pre>
假设有A、B两个数据，值分别为1、2：

1） 事务开始

2） 记录A=1到undo log buffer

3) 修改A=3

4) 记录B=2到undo log buffer

5） 修改B=4

6) 将undo log写到磁盘

7) 将数据写到磁盘

8) 事务提交
</pre>

- 如何保证持久性？

事务提交前，会把修改数据刷到磁盘，也就是说只要事务提交了，数据肯定持久化了。

- 如何保证原子性？

每次对数据库修改，都会把修改前数据记录在undo log中，那么需要回滚时，可以读取undo log，恢复数据。

- 若系统在7) 和8） 之间崩溃，如何处理？

此时事务并未提交，需要回滚。而undo log已经被持久化，可以根据undo log来恢复数据。

- 若系统在7)之前崩溃，如何处理？

此时数据并未持久化到硬盘，依然保持在事务之前的状态。


----------
**缺陷：** 每个事务提交前将数据和undo log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。

如果能够将数据缓存一段时间，就能减少IO提高性能，但是这样就会丧失事务的持久性，因此引入了另外一种机制来实现持久化，即redo log。

### 2.2 redo log

和undo log相反，redo log记录的是**新数据**的备份。在事务提交前，只要将redo log持久化即可，不需要将数据持久化，减少了IO的次数。

先来看一下基本原理，undo + redo事务的简化过程：
<pre>
假设有A、B两个数据，值分别为1，2：

1） 事务开始；

2) 记录A=1到undo log buffer；

3) 修改A=3；

4) 记录A=3到redo log buffer;

5) 记录B=2到undo log buffer；

6) 修改B=4；

7) 记录B=4到redo log buffer；

8） 将undo log写入磁盘；

9) 将redo log写入磁盘；

10) 事务提交
</pre>

###### 2.2.1 安全性和性能问题
- 如何保证原子性？

如果在事务提交前故障，通过undo log日志恢复数据。如果undo log都还没写入，那么数据就尚未持久化，无需回滚。

- 如何保证持久化？

大家会发现，这里并没有出现数据的持久化。因为数据已经写入redo log，而redo log持久化到了硬盘，因此只要到了步骤9）以后，事务是可以提交的。

- 内存中的数据库数据何时持久化到磁盘？

因为redo log已经持久化，因此数据库数据写入磁盘与否影响不大，不过为了避免出现脏数据（内存中与磁盘不一致），事务提交后也会将内存数据刷入磁盘（也可以按照设定的频率刷新内存数据到磁盘中）。

- redo log何时写入磁盘？

redo log会在事务提交之前，或者redo log buffer满了的时候写入磁盘。

###### 2.2.2 存在的问题
这里存在两个问题：

1） **问题1： 之前是写undo和数据库数据到硬盘，现在是写undo和redo到磁盘，似乎没有减少IO次数**

- 数据库数据写入是随机IO，性能很差；

- redo log在初始化时会开辟一段连续的空间，写入是顺序IO，性能很好；

- 实际上undo log并不是直接写入磁盘，而是先写入到undo log buffer中，当redo log持久化时，undo log就同时持久化到硬盘了。

因此事务提交前，只需要对redo log持久化即可。

另外，redo log并不是写入一次就持久化一次，redo log在内存中也有自己的缓冲池```redo log buffer```。每次写redo log都是写入到buffer，在提交时一次性持久化到磁盘，减少IO次数。



2） **问题2： redo log数据是写入内存buffer中，当buffer满或者事务提交时，将buffer数据写入磁盘。redo log中记录的数据，有可能包含尚未提交的事务，如果此时数据库崩溃，那么如何完成数据恢复？**

数据恢复有两种策略：

* 恢复时，只重做已经提交了的事务

* 恢复时，重做所有事务， 包括未提交的事务和回滚了的事务。然后通过undo log回滚那些未提交的事务。

InnoDB引擎采用的是第二种方案，因此undo log要在redo log前持久化。 



Inodb引擎采用的是第二种方案，因此undo log要在 redo log前持久化





<br />
<br />

**[参看]:**

1. [分布式事务解决方案](https://www.cnblogs.com/the-zym/p/13230674.html)

2. [分布式系统一致性解决方案](https://blog.csdn.net/kevin860/article/details/82322519)


<br />
<br />
<br />


