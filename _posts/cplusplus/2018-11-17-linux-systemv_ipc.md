---
layout: post
title: 多进程之间的通信
tags:
- cplusplus
categories: cplusplus
description: 多进程之间的通信
---


多进程之间有很多种方式，比如管道、socket、System V IPC等。本章我们讲述一下三种System V IPC：

* 信号量

* 共享内存

* 消息队列


<!-- more -->

## 1. 信号量

### 1.1 信号量原语

当多个进程同时访问系统上的某个资源的时候，比如同时写一个数据库的某条记录，或者同时修改某个文件，就需要考虑进程的同步问题，以确保任一时刻只有一个进程可以拥有对资源的独占式访问。通常，程序对共享资源的访问的代码只是很短的一段，但就是这一段代码引发了进程之间的竞态条件。我们称这段代码为```关键代码段```，或者```临界区```。对进程同步，也就是确保任一时刻只有一个进程能进入关键代码段。

要编写具有通用目的的代码，以确保关键代码段的独占式访问是非常困难的。有两个名为```Dekker算法```和```Peterson算法```的解决方案，它们试图从语言本身（不需要内核支持）解决并发问题。但它们依赖于忙等待，即进程要持续不断地等待某一个内存位置状态的改变。这种方式下CPU利用率太低，显然是不可取的。

Dijkstra提出的信号量(Semaphore)概念是并发编程领域迈出的重要一步。信号量是一种特殊的变量，它只能取```自然数值```并且只支持两种操作: 等待(wait)和信号(signal)。不过在Linux/Unix中，```等待```和```信号```都已经具有特殊的含义，所以对信号量的这两种操作更通常称呼是**P**、**V**操作。这两个字母来自于荷兰语单词```passeren```(传递，就好像进入临界区）和```vrijgeven```(释放，就好像退出临界区)。假设有信号量SV，则对它的**P**、**V**操作含义如下：

<pre>
P(SV): 如果SV的值大于0，就将它减1； 如果SV的值等于0，则挂起进程的执行。

V(SV): 如果有其他进程因为等待SV而挂起，则唤醒之； 如果没有，则将SV加1.
</pre>

信号量的取值可以是任何自然数。但最常用的、最简单的信号量是二进制信号量，它只能取0和1两个数值。这里我们也仅讨论二进制信号量。使用二进制信号量同步两个进程，以确保关键代码段的独占式访问的一个典型例子如下图所示：



在上图中，当关键代码段可用时，二进制信号量SV的值为1，进程A和B都有机会进入关键代码段。如果此时进程A执行了```P(SV)```操作将SV减1，则进程B若再执行```P(SV)```操作就会被挂起。直到进程A离开关键代码段，并执行```V(SV)```操作将SV加1，关键代码段才重新变得可用。如果此时进程B因为等待SV而处于挂起状态，则它将被唤醒，并进入关键代码段。同样，这时进程A如果再执行```P(SV)```操作，则也只能被操作系统挂起以等待进程B退出关键代码段。
{% highlight string %}
注意： 使用一个普通变量来模拟二进制信号量是行不通的，因为所有高级语言都没有一个原子操作可以同时
      完成如下两步操作： 检测变量是否为true/false，如果是则再将它设置为false/true。
{% endhighlight %}

Linux信号量的API都定义在sys/sem.h头文件中，主要包含3个系统调用： semget()、setop()和semctl()。它们都被设计为操作一组信号量，即```信号量集```，而不是单个信号量，因此这些接口看上去多少比我们期望的要复杂一点。我们将分成3个部分来依次讨论之：

### 1.2 semget系统调用
semget系统调用创建一个新的```信号量集```,或者获取一个已存在的信号量集。其定义如下：
{% highlight string %}
#include <sys/sem.h>

int semget(key_t key, int num_sems, int sem_flags);
{% endhighlight %}

key参数是一个键值，用来标识



### 1.3 semop系统调用

### 1.4 semctl系统调用





<br />
<br />

**[参看]**





<br />
<br />
<br />


