---
layout: post
title: Linux死锁现象及分析方法（转）
tags:
- cplusplus
categories: cplusplus
description: Linux死锁现象及分析方法
---


本节我们对Linux死锁做一个基本的介绍，然后讲解如何检测并定位死锁。


<!-- more -->



## 1. 什么是死锁？
死锁（DeadLock)是指两个或者两个以上的进程（线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程(线程）。由于资源占用是互斥的，当某个进程提出申请后，使得有关进程（线程）在无外力协助下，永远分配不到必需的资源而无法继续进行，这就产生了一种特殊现象——```死锁```。

一种```交叉持锁```死锁的情形，此时执行程序中两个或多个线程发生永久堵塞（等待），每个线程都在等待被其他线程占用并堵塞了的资源。例如，如果```线程1```锁住了记录A并等待记录B，而```线程2```锁住了记录B并等待记录A，这样两个线程就发生了死锁现象。在计算机系统中，如果系统的资源分配策略不当，更常见的可能是程序员写的程序有错误等，则会导致进程因竞争资源不当而产生死锁的现象。

## 2. 产生死锁的四个必要条件

1) **对临界资源的互斥使用(资源独占）**

一个资源每次只能给一个进程（线程）使用。比如写操作


2） **占有且等待**

进程在申请新的资源的同时，保持对原有资源的占有。

3） **不可抢占**

资源申请者不能强行从资源占有者手中夺取资源，资源只能由占有者自愿释放。

4) **循环等待**

P1等待P2占有的资源，P2等待P3占有的资源， ... Pn等待P1占有的资源，形成一个进程等待回路。

## 3. 一个例子及图示

### 3.1 图示

![cpp-dead-lock](https://ivanzz1001.github.io/records/assets/img/cplusplus/cpp_dead_lock.jpg)




<br />
<br />

**[参看]**

1. [死锁现象及分析方法](https://blog.csdn.net/breaksoftware/article/details/81365851)

2. [死锁问题分析的利器](https://blog.csdn.net/breaksoftware/article/details/81365851)

3. [死锁的四个必要条件和解决办法](https://blog.csdn.net/guaiguaihenguai/article/details/80303835)
<br />
<br />
<br />


