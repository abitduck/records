---
layout: post
title: GDB的使用(part1)
tags:
- cplusplus
categories: cplusplus
description: GDB的使用
---

本文档主要参看<<Debugging with GDB>> ```Tenth Edition, for gdb version 8.0.1```，详细的介绍一下GDB的使用方法。

<!-- more -->


## 1. GDB的启动与退出
本节我们主要讲述一下如何启动以及退出GDB，主要包含如下：

* 输入```gdb```来启动gdb调试

* 输入```quit```或者```Ctrl-D```来退出GDB

### 1. 启动GDB
下面描述的命令行选项在覆盖大部分使用场景；但是在有一些环境中，有一些选项可能会不能够使用。通常情况下，在启动gdb时传入```可执行程序名```这样一个参数即可：
<pre>
# gdb program
</pre>
你也可以在启动时同时指定一个```可执行程序名```和一个```core```文件：
<pre>
# gdb program core
</pre>
另外，假如你想调试一个正在运行的进程的话，也可以在启动时指定一个进程ID作为第二个参数：
<pre>
# gdb program 1234
</pre>
上面的命令会将进程1234绑定到GDB（除非你恰好有一个名称为1234的文件，这种情况下将会优先将1234作为一个core文件来看待）。

如果要使用第二个命令行参数，一般要求有一个完整的操作系统环境；而当你使用GDB来远程调试一个主板的时候，这很可能没有```进程```的概念，并且通常也无法获取到一个coredump文件。假如gdb并不能attach到一个进程，或者并不能读取到core dump文件的时候，其都会给出相应的警告。


此外，我们也可以通过```--args```选项来为gdb所调试的可执行程序传递参数。```注意```：此选项会使得gdb不再处理其他的选项了。例如：
<pre>
# gdb --args gcc -O2 -c foo.c
</pre>
上面的命令将会导致gdb调试gcc这个可执行程序，并且设置gcc的命令行参数为```-O2 -c foo.c```。


在启动GDB时，我们可以通过传递```--silent```(或```-q```/```--quiet```)来禁止gdb的一些前置消息的打印（例如gdb版本号之类的）。我们还可以使用```gdb --help```或者```gdb -h```来获得更多关于gdb的帮助信息。

通常情况下，gdb都是按命令行传递的顺序来处理```参数```和```选项```的。但是你可以使用```-x```选项来修改顺序。



### 1.2 选择文件
当gdb启动之后，其会读取任何参数（而不是选项）以作为可执行文件和core dump文件（或进程pid)。这与分别通过```-se```、```-c```(或```-p```）选项来指定是一样的。（gdb会读取第一个不带选项的参数，将其看做是带了```-se```选项； 接着读取第二个不带选项打的参数，将其看做是带了```-c```或```-p```选项）。假如第二个参数是一个```十进制数```，则gdb会尝试将其attach到一个进程，假如attach失败，则尝试将其当做一个core dump文件来看待。因此，假如你刚好有一个名称以数字开头的coredump文件，你可以通过类似于```./1234```这样的方式来避免gdb将其当成是一个pid。

在大多数嵌入式系统当中，gdb可能并未配置有包含core dump功能的支持，这时如遇到第二个参数，则会打印相应的警告信息并且忽略该参数。



下面我们列出gdb支持的一些选项：

* ```--symbols file```(或```-s file```): 从file文件中读取符号表

* ```--exec file```(或```-e file```): 将file作为可执行文件来执行，并将该参数后的另外一个不带选项的参数作为core dump文件

* ```--se file```: 从文件中读取符号表，并将其作为一个可执行文件

* ```--core file```(或```-c file```): 将file作为一个core dump文件

* ```--pid number```(或```-p number```): 连接到指定pid的进程，相当于执行了一个```attach```命令。

* ```--command file```(或```-x file```): 从file文件中执行相应的命令。对文件内容的执行严格参照```source```命令的执行。

* ```--eval-command command```(或```-ex command```): 执行一个单独的gdb命令。本选项可多次使用，以调用多个命令。也可以搭配```--command```来使用。例如：
<pre>
# gdb -ex 'target sim' -ex 'load' \
  -x setbreakpoints -ex 'run' a.out
</pre>

* ```--init-command file```(或```-ix file```): 在加载可执行文件之前先执行file文件中指定的命令。

* ```-init-eval-command command```(或```-iex command```): 在加载可执行文件之前先执行一个单独的gdb命令

* ```-directory directory```(或```-d directory```): 将directory添加到gdb搜寻源文件及脚本文件的路径当中

* ```--readnow```(或```-r```): 马上读取每一个符号文件的所有符号表。默认情况下，读取符号表是根据所需以递增的方式来执行的。这会使得加载速度变慢，但是后续的执行速度会更快。





### 1.3 选择gdb的执行模式
你可以以不同的模式来运行gdb，例如```batch```模式或```quiet```模式。下面介绍几个常用的：

* ```-nx```或```-n```: 并不要执行任何```初始化文件```中的命令。3个初始化文件会按照如下的顺序来加载
<pre>
1) system.gdbinit: 这是系统级别的初始化文件，可以通过--with-system-gdbinit选项来指定。一般在GDB
    启动之后，在处理任何选项之前就会被加载

2） ~/.gdbinit: 这是当前home目录的初始化文件，其会在system.gdbinit之后但在处理任何选项之前被加载。

3） ./.gdbinit: 这是当前目录下的初始化文件。其一般会在最后加载（但是注意会在-x或-ex选项之前加载）
</pre>


* ```--quiet```或```--silent```或```-q```: 表示以安静模式启动gdb，不要打印相关的介绍信息和版权信息。

* ```--args```:用于改变对命令行的解释，使得在可执行文件后面的参数会作为可执行文件的参数，而不是gdb的参数来处理。注意： 本选项会停止gdb的选项处理，因为gdb会认为这些选项都是属于可执行文件的。

* ```--version```: 用于使gdb在使用时打印相关的版本信息



### 1.4 GDB启动流程
下面我们讲述一下GDB的一个启动流程：

1） 根据命令行的指定初始化对应的命令解释器（参看上一节```GDB的执行模式```)

2) 读取系统级别的```init```文件（即在编译gdb时通过```--with-system-gdbinit```选项指定的文件），并执行其中的命令

3) 读取home目录的```init```文件并执行其中的命令

4） 按顺序执行由```-iex```选项指定的命令，或```-ix```选项指定的文件中的命令。你也可以使用```-ex```或者```-x```来替换前面的选项，但是在这种情况下其会在gdbinit之前被执行

5） 处理命令行选项和参数

6）假如当前目录并不是```home```目录，且```set auto-load local-gdbinit```值为```on```时，则会读取和执行当前工作目录下的gdbinit文件。

7） 如果命令行指定了要调试的```program```，或者要attach到一个进程，或者一个core dump文件，那么gdb会加载该```program```所需要的自动加载文件或共享库。假如你想要在gdb启动时禁止这个自动加载，那么类似于如下：
<pre>
# gdb -iex "set auto-load python-scripts off" myprogram
</pre>
说明： 这里并不能用```-ex```选项，因为这会使得关闭```auto-load```太晚

8) 执行```-ex```选项指定的命令，或```-x```选项指定的文件中的命令

9） 读取```history file```中的历史命令




### 1.4 退出GDB

```quit [expression]```或```q```: 我们可以通过```quit```或```q```来退出GDB，也可以通过```End of File```字符（一般为```Ctrl-d```)来退出。假如你并未指定```[expression]```的话，则GDB会正常的退出； 否则会使用该表达式的结果作为退出码。

```Ctrl-c```并不能退出GDB，只是会中断当前GDB正在执行的命令并返回到GDB命令行。

另外，假如你当前正在使用gdb来控制一个attach的进程或者device，那么你可以通过detach命令来进行释放。


### 1.5 shell命令
假如你想在gdb调试期间执行shell命令，可以不用退出或挂起GDB，你可以直接使用shell命令：```shell command-string```或者```!command-string```。





## 2. 在GDB下运行程序
当你需要在GDB下运行程序的时候，你必须在编译的时候产生相应的调试信息。你可以根据自身的环境，在启动GDB时指定相应的参数。假如你进行的是本地调试，你还可以对所要调试的程序输入输出进行重定向； 可以调试一个正在运行的程序；或者kill掉一个子进程。



### 2.1 编译调试程序
为了有效的调试程序，你需要在编译的时候产生相应的调试信息。这些调试信息被存放在对象文件件中(```.o```文件）： 其描述了每一个变量及函数的数据类型，在源文件中的行号以及在可执行文件中对应的地址。


要产生调试信息，需要在编译的时候指定```-g```选项。通常情况下，交付给客户的程序在编译时都通过```-o```编译选项进行了优化。然而，有一些编译器并不能同时处理```-g```与```-o```两个选项，因此，当使用这些编译器的时候，并不能生成带有调试信息的优化版本的可执行文件。


对于GCC(GNU C/C++编译器），是支持```-g```与```-o```两个选项同时出现的，这就使得gdb能够调试优化过的代码。通常情况下，我们建议在编译程序的时候都带上```-g```选项。另外，对于一些老版本的GNU C编译器，其支持一个变体的```-gg```选项用于产生调试信息，但是当前gdb并不支持该格式。因此当你的GNU C编译器即使支持该选项时，也不要使用。

GDB可以识别预处理宏定义，并能显示这些宏定义的扩展。但是大多数的编译器在你单独指定```-g```选项产生的调试信息中并不包含预处理宏定义。对于GCC3.1及其之后的版本，假如使用```DWARF```调试格式并指定```-g3```的情况下，是可以提供宏信息的。

当你所用的编译器支持最新版本的```DWARF```调试格式的时候，你将能够获得最好的调试体验。```DWARF```是当前GDB支持最好的调试格式。





### 2.2 运行程序
在GDB下，可以使用```run```或者```r```命令来启动程序。假如你当前是在一个支持```进程```的执行环境下运行程序，```run```命令首先会创建一个进程，然后采用该进程来运行的可执行程序。而对于有一些不支持进程的环境，```run```则会直接跳转到你的可执行程序的开始位置处。对于其他的target，例如```remote target```，这些target在你运行gdb时总是处于运行状态。因此假如你获得类似于如下的错误消息的话：
<pre>
The "remote" target does not support "run".
Try "help target" or "continue".
</pre>
则之后你可以使用```continue```来运行程序。但是这可能需要你首先load。


通常，一个程序的执行会受到管理进程的多方面的影响。一般你可以在启动可执行程序之前，通过GDB以多种方式提供相应的信息以影响你所要调试程序的执行。这些信息通常可以分成4类：

* 参数(arguments)： 为可执行程序指定参数，并将此作为```run```命令的参数。

* 环境(environment):

* 工作目录(working directory):

* 标准输入输出(standard input and output):










<br />
<br />

**[参看]**






<br />
<br />
<br />





