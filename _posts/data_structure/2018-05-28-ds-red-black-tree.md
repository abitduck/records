---
layout: post
title: 红黑树的原理及实现
tags:
- data-structure
categories: data-structure
description: 红黑树的原理及实现
---


本文我们从内存数据的```查找```出发, 引出```2-3```树， 然后在此基础上讲述一下红黑树的原理及实现。


<!-- more -->


## 1. 查找

我们使用```符号表```这个词来描述一张抽象的表格，我们会将信息（值）存储在其中， 然后按照指定的键来搜索并获取这些信息。键和值的具体意义取决于不同的应用。符号表可能会保存很多键和很多信息，因此实现一张高效的符号表也是一项很有挑战的任务。

我们一般会用三种经典的数据类型来实现高效的符号表： 二叉查找树、红黑树、散列表


### 1.1 二分查找

我们使用有序数组来存储```键```，经典的二分查找能够根据数组的索引大大减少每次查找所需的比较次数。在查找时，我们先将被查找的键和子数组的中间键比较。如果被查找的键小于中间键，我们就在左子数组中继续查找； 如果大于我们就在右子数组中继续查找，否则中间键就是我们要找的键。

一般情况下，二分查找都比顺序查找快得多， 它也是众多实际应用程序的最佳选择。对于一个静态表（不允许插入）来说，将其在初始化时就排好序是值得的。

当然，二分查找也有很多应用场景下不适合。现代应用需要同时能够支持高效的查找和插入两种操作的符号表实现。 也就是说， 我们需要在构造庞大的符号表的同时能够任意插入（也许还有删除）键值对，同时也要能够完成查找操作。

要支持高效的插入操作，我们似乎需要一种链式结构。但单链接的链表是无法使用二分查找的，因为二分查找的高效来自于能够快速通过索引取得任何子数组的中间元素。为了将二分查找的效率和链表的灵活性结合起来，我们需要更加复杂的数据结构。

能够同时拥有两者的就是```二叉查找树```。

### 1.2 二叉查找树

一棵二叉查找树(BST)是一棵二叉树，其中每个节点都含有一个可比较的键（以及相关联的值）且每个节点的键都大于其左子树任意节点的键而小于右子树的任意节点的键。

![ds-bst-figure1](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_bst_figure1.jpg)

一棵二叉树代表了一组键（及其相应值）的集合，而同一集合可以用多棵不同的二叉树表示。如果我们将一棵二叉查找树的所有键投影到一条直线上，保证一个节点的左子树中的键出现在它的左边， 右子树中的键出现在它的右边，那么我们一定可以得到一条有序的键列：

![ds-bst-figure2](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_bst_figure2.jpg)








<br />
<br />
**[参看]:**


1. [查找（一）史上最简单清晰的红黑树讲解](http://blog.csdn.net/yang_yulei/article/details/26066409)

2. [红黑树的插入与删除](http://m.blog.csdn.net/article/details?id=51504764)

3. [浅谈算法和数据结构：八 平衡查找树之2-3树](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)

4：[浅谈算法和数据结构： 九 平衡查找树之红黑树](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html) 

5：[数据结构： 2-3树与红黑树](http://blog.csdn.net/aircattle/article/details/52347955)


<br />
<br />
<br />


