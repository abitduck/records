---
layout: post
title: B-树详解
tags:
- data-structure
categories: data-structure
description: B树详解
---

本文详细介绍一下B树的实现。


<!-- more -->

## 1. B-树

```B-tree```树即```B树```, 这里B即Balanced的意思。因为B树的原英文名称为```B-tree```,而国内很多人喜欢把```B-tree```翻译为```B-树```, 其实这是个非常不好的直译， 很容易让人产生误解。如人们可能会以为```B-树```是一种树， 而```B树```又是另外一种树。事实上，```B-tree```就是指的```B树```，特此说明。

### 1.1 B-树的定义

```B-树```是一种平衡的多路查找树， 它在文件系统中很有用。我们在这里先介绍一下这种树结构。

一颗```m阶```的```B-树```, 或为空树，或为满足下列特性的```m叉```树:

* 树中每个节点至多有m颗子树；

* 若根节点不是叶子节点，则至少有两颗子树

* 除根以外的所有非终端节点至少有```⌈m/2⌉```棵```子树```

* 所有的非终端节点中包含下列信息数据
<pre>
     (n, A0, K1, A1, K2, A2, ... , Kn, An)
</pre>
其中： ```Ki(i=1, ... ,n)```为关键字，且```Ki<Ki+1(i=1, ... ,n-1)```; ```Ai(i=0, ... ,n)```为指向子树根节点的指针， 且```Ai-1```所指子树中所有节点的关键字均小于```Ki(i=1, ... ,n)```，```An```所指子树中所有关键字均大于```Kn```，```n(⌈m/2⌉-1 <= n<= m-1)```为关键字的个数（n+1为子树个数)

* 所有的叶子节点都出现在同一层次上，并且不带信息（可以看作是外部节点或查找失败的节点，实际上这些节点不存在，指向节点的指针为空）

下图所示为一颗```4阶```的```B-树```, 其深度为4(```F```为叶子节点）:

![ds-btree](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_btree.jpg)

### 1.2 B-树的特性
由```B-树```的定义可以知道，其具有如下特性：

* 关键字集合分布在整棵树中；

* 任何一个关键字出现且只出现在一个节点中

* 搜索有可能在非叶子节点结束

* 其搜索性能等价于在关键字全集内做一次```二分查找```

* 自动层次控制： 由于限制了除根节点以外的非叶子节点，至少含有```⌈m/2⌉```个儿子，确保了节点的至少利用率

## 2. B-树的查找
由```B-树```的定义可知，在```B-树```上进行查找的过程和```二叉排序树```的查找类似。例如，在上图所示的B树中查找关键字```47```的过程如下：首先从根开始，根据根节点指针```t```找到```*a```节点，因```*a```节点中只有一个关键字，且给定值```47```大于关键字```35```, 则若存在必在指针A1所指的子树内；顺指针找到```*c```节点，该节点有两个关键字(43和78)，而43<47<78,则若存在必在指针A1所指的子树中。同样顺指针找到```*g```节点，在该节点中顺序查找到关键字47, 由此查找成功。查找不成功的过程也类似，例如在同一棵树中查找23。从根开始，因为23<35，则顺该节点中指针A0找到```*b```节点，又因为```*b```节点中只有一个关键字18，且23>18，所以顺节点中第二个指针A1找到```*e```节点。同理因为23<27,则顺指针往下找，此时因指针所指为叶子节点，说明此棵```B-树```中不存在关键字23,查找失败而告终。

由此可见，在```B-树```上进行查找的过程是一个顺指针查找节点和在节点的关键字中进行查找交叉进行的过程，即```B-树```的查找过程为：

* 在```B-树```中查找节点

* 在节点中查找关键字

由于```B-树```通常存储在磁盘上，则前一查找操作是在磁盘上进行的，而后一查找操作是在内存中进行的，即：在磁盘上找到指针p所指的节点后，先将节点信息读入内存，然后再利用顺序查找或折半查找查询等于K的关键字。显然，在磁盘上进行一次查找比在内存中进行一次查找的时间消耗的多得多。因此，在磁盘上进行查找的次数，即待查关键字所在节点在```B-树```上的层次数是决定B书查找效率的首要因素。


## 3. B树的插入
其实```B-树```的插入是很简单的，它主要分为如下两个步骤：

**1）** 使用之前介绍的查找算法查找出关键字的插入位置， 如果我们在```B-树```中查找到了关键字， 则直接返回； 否则它一定会失败在某个最低层的终端节点上

**2）** 然后， 我们就需要判断那个终端节点上的关键字是否满足```n<=m-1```, 如果满足的话，就直接在该终端节点上添加一个关键字， 否则我们就需要产生节点的```分裂```。

节点分裂的方法是： 生成一个新节点。然后把原节点上的关键字和```k```(需要插入的值)按升序排列， 从中间位置把关键字分成左右两个部分(形成3个部分： 左半部分、中间关键字、右半部分)。再接着把左半部分所含关键字放在旧节点中，右半部分所含关键字放在新节点中， 中间位置的关键字连同新节点的地址插入到父节点中。如果父节点的关键字个数也超过```m-1```，则要再分裂，再往上插入，直至这个过程传到根节点为止。

下面我们举个例子进行说明。这里假设这棵```B-树```的阶为3，树在初始化时如下：

![ds-btree-insert0](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_btree_insert0.jpg)

首先，我们需要插入一个关键字```30```，可以得到如下结果：

![ds-btree-insert1](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_btree_insert1.jpg)

再插入```26```， 得到如下结果：

![ds-btree-insert2](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_btree_insert2.jpg)

如上所示，在插入的那个终端节点中，它的关键字数已经超过了```m-1```，所以我们需要对节点进行分裂。我们先对关键字进行排序，得到：```26 30 37```，它的左半部分为 26，中间值为30， 右半部分是37。然后我们将左半部分放在原来的节点，右半部分放在新的节点，而中间值则插入到父节点，并且父节点会产生一个新的指针，指向新的节点位置，如下图所示：

![ds-btree-insert3](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_btree_insert3.jpg)


<br />
<br />
**[参看]:**

1. [B-树的详解](https://blog.csdn.net/qq_35644234/article/details/66969238)

2. [从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142)


<br />
<br />
<br />


