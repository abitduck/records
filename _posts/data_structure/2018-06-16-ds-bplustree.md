---
layout: post
title: B+树详解
tags:
- data-structure
categories: data-structure
description: B+树详解
---

本文详细介绍一下B+树的相关原理及实现。


<!-- more -->

## 1. B+树

```B+树```是一种数据结构，是一个N叉排序树，每个节点通常有多个孩子，一棵```B+树```包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点， 也可能是一个包含两个或两个以上孩子节点的节点。

```B+树```通常用于数据库和操作系统的```文件系统```中。NTFS、ReiserFS、NSS、XFS、JFS、ReFS和BFS等文件系统都在使用```B+树```作为元数目索引。```B+树```的特点是能够保持数据稳定有序， 其插入与修改拥有较稳定的对数时间复杂度。```B+树```元素自底向上插入。

### 1.1 B+树的定义

```B+树```是应文件系统所需而出的一种```B-树```的变型树。一棵```m阶```的```B+树```和m阶的```B-树```的差异在于：

**1)** 有n棵子树的节点中含有n个关键字(即每个关键字对应一棵子树)；

**2)** 所有叶子节点中包含了全部关键字的信息， 及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接； 

**3)** 所有的非终端节点可以看成是索引部分，节点中仅含有其子树（根节点）中的最大（或最小)关键字

**4)** 除根节点外，其他所有节点中所含关键字的个数必须```>=⌈m/2⌉```(注意： ```B-树```是除根以外的所有非终端节点至少有```⌈m/2⌉```棵子树)

下图是所示为一棵3阶的```B+树```，通常在```B+树```上有两个指针头， 一个指向根节点，另一个指向关键字最小的叶子节点。因此，可以对```B+树```进行两种查找运算： 一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。

![ds-bplus-tree1](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_bplus_tree1.jpg)

下图是另一棵```3阶B+树```:

![ds-bplus-tree2](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_bplus_tree2.jpg)

### 1.2 B+树的特性

* 所有关键字都出现在叶子节点的链表中（稠密索引），且链表中的关键字恰好是有序的；

* 不可能在非叶子节点命中；

* 非叶子节点相当于叶子节点的索引（稀疏索引），叶子节点相当于是存储（关键字）数据的数据层；

* 更适合文件索引系统；

## 2. B+树的查找
对```B+树```可以进行两种查找运算：

**1)** 从最小关键字起顺序查找；

**2)** 从根节点开始，进行随机查找

在查找时，若非终端节点上的关键字等于给定值，并不终止，而是继续向下直到叶子节点。因此，在```B+树```中，不管查找成功与否，每次查找都是走了一条从根到叶子节点的路径。其余同```B-树```的查找类似。

## 3. B+树的插入

m阶```B+树```的插入操作在叶子节点上进行，假设要插入关键值```a```，找到叶子节点后插入```a```，做如下算法判别：

**1)** 如果当前节点是根节点，并且插入后节点关键字数目小于等于```m```，则算法结束；

**2)** 如果当前节点是非根节点， 并且插入后节点关键字数目小于等于m，则判断若```a```是新索引值时转```步骤4)```后结束，若```a```不是新索引值，则直接结束；

**3)** 如果插入后关键字数目大于```m```，则先分裂成两个节点```X```和```Y```，并且他们各自所含的关键字个数分别为： u=```⌈(m+1)/2⌉```, v=```⌊(m+1)/2⌋```。由于索引值位于节点的最左端或最右端，不妨假设索引值位于节点的最右端（即非终端节点含有其子树中的最大关键字）， 有如下操作：

* 如果当前分裂成的```X节点```和```Y节点```原来所属的节点是根节点，则从```X节点```和```Y节点```中取出索引关键字，将这两个关键字组成新的根节点，并且这个根节点指向```X```和```Y```，算法结束；

* 如果当前分裂成的```X节点```和```Y节点```原来所属的节点是非根节点，依据假设条件判断，如果```a```成为```Y节点```的新索引值，则转至```步骤4)```得到```Y```双亲节点```P```；如果```a```不是```Y```节点的新索引值，则求出```X节点```和```Y节点```的双亲节点```P```。然后提取```X节点```的新索引值```a'```，在```P```中插入关键字```a'```，继续进行插入算法；

**4)**  提取节点原来的索引值```b```，自顶向下先判断根是否含有```b```，如果含有则需要先将```b```替换为```a```。然后从根开始，记录节点地址```P```, 判断```P```的孩子是否含有新索引值```b```而不含索引值```a```，如果是则将孩子节点中的```b```替换为```a```，然后将```P```的孩子的地址赋值给```P```，继续搜索，直到发现```P```的孩子中已经有```a```值时，停止搜索，返回地址```P```。




<br />
<br />
**[参看]:**

1. [B-树，B+树，B*树详解](https://blog.csdn.net/aqzwss/article/details/53074186)

2. [原B+tree详解及实现(C语言)](https://blog.csdn.net/xiaohusaier/article/details/77101640)

3. [B+树](https://baike.baidu.com/item/B+%E6%A0%91/7845683)

<br />
<br />
<br />


