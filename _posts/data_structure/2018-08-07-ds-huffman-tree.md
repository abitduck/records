---
layout: post
title: 赫夫曼树及其应用
tags:
- data-structure
categories: data-structure
description: 赫夫曼树及其应用
---

本章我们主要介绍一下赫夫曼树及其应用。赫夫曼(Huffman)树，又称最优树，是一类带权路径长度最短的树，有着广泛的应用。


<!-- more -->


## 1. 最优二叉树（赫夫曼树)

首先给出路径和路径长度的概念。从树中一个节点到另一个节点之间的分支构成这两个节点之间的路径，路径上的分支数目称作**路径长度**。**树的路径长度**是从树根到每一节点的路径长度之和。完全二叉树就是这种路径长度最短的二叉树。

若将上述概念推广到一般情况，考虑带权的节点。节点的带权路径长度为从该节点到树根之间的路径长度与节点上权的乘积。树的带权路径长度为树中所有```叶子节点```的带权路径长度之和，通常记作：![ds-huffman-length](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_huffman_length.jpg)


假设有```n```个权值{W1,W2,..., Wn}，试构造一棵有n个叶子节点的二叉树，每个叶子节点带权路径长度为```Wi```，则其中带权路径长度WPL最小的二叉树称作**最优二叉树**或**赫夫曼树**。

例如，下图所示的3棵二叉树，都有4个叶子节点a、b、c、d，分别带权7、5、2、4，它们的带权路径长度分别为：
<pre>
 (a) WPL = 7 x 2 + 5 x 2 + 2 x 2 + 4 x 2 = 36
 (b) WPL = 7 x 3 + 5 x 3 + 2 x 1 + 4 x 2 = 46
 (c) WPL = 7 x 1 + 5 x 2 + 2 x 3 + 4 x 3 = 35
</pre>
其中以(c)树的带权路径长度为最小。可以验证，它恰为赫夫曼树，即其带权路径长度在所有带权为7、5、2、4的4个叶子节点的二叉树中居最小。

![ds-weight-tree](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_weight_tree.jpg)

在解某些判问题时，利用赫夫曼树可以得到最佳判定算法。例如，要编制一个将百分制转换成五级分制的程序。显然，此程序很简单，只要利用条件语句便可完成。如：
{% highlight string %}
if(a < 60)
	b = "bad";
else if(a < 70)
	b = "pass";
else if(a < 80)
	b = "general";
else if(a < 90)
	b = "good";
else 
	b = "excellent";
{% endhighlight %}
这个判定过程可以下图(a)的判定树来表示。如果上述程序反复使用，而且每次的输入量很大，则应考虑上述程序的质量问题，即其操作所需的时间。因为在实际生活中，学生的成绩在5个等级上的分布是不均匀的。假设其分布规律如下表所示：

|  分数 |  0-59    |   60-69  |  70-79  |   80-89   |  90-100  |
|:-----:|:--------:|:--------:|:-------:|:---------:|:--------:|
|比例数 |   0.05   |   0.15   |  0.40   |   0.30    |   0.10   |

则80%以上的数据需进行3次或3次以上的比较才能得出结果。假定以5,15,40,30和10为权构造一颗有5个叶子节点的赫夫曼树，则可得到下图(b)所示的判定过程，它可使大部分的数据经过较少的比较次数得出结果。但由于每个判定框都有两次比较，将这两次比较分开，我们得到下图（c）所示的判定树，按此判定树可写出相应的程序。假设现有10000个输入数据，若按图(a)的判定过程进行操作，则总共需进行31500次比较；而若按图(c)的判定过程进行操作，则总共需进行22000次比较。

![ds-score-decide](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_score_decide.jpg)

那么，如何构造赫夫曼树呢？赫夫曼最早给出了一个带有一般规律的算法，俗称赫夫曼算法。现叙述如下：

1) 根据给定的n个权值{W1, W2, ..., Wn}构成n棵二叉树的集合F={T1,T2, ..., Tn}，其中每棵二叉树```Ti```中只有一个带权为```Wi```的根节点，其左右子树均空。

2) 在F中选取两棵根节点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根节点的权值为其左、右子树上根节点的权值之和。

3） 在F中删除这两棵树，同时将新得到的二叉树加入F中

4） 重复2)和3)，直到F中只含一棵树为止。这棵树便是赫夫曼树。

例如，下图展示了权值为7、5、2、4的节点构造赫夫曼树的过程。其中，根节点上标注的数字是所赋的权。

![ds-huffman-create](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_huffman_create.jpg)


<br />
<br />


