---
layout: post
title: 串的模式匹配算法
tags:
- data-structure
categories: data-structure
description: 串的模式匹配算法
---

本章我们主要介绍一下串的模式匹配算法。


<!-- more -->

## 1. 求子串位置的定位函数
子串的定位操作通常称作串的```模式匹配```(其中T称为**模式串**)，是各种串处理系统中最重要的操作之一。下面我们给出一个**采用定长顺序存储结构**子串定位算法：
{% highlight string %}
#define MAXSTRLEN	255		//用户可在255以内定义最大串长
typedef unsigned char SString[MAXSTRLEN+1];	//0号单元存放串的长度

//返回子串T在主串S中第Pos个字符之后的位置。若不存在，则函数值为0
//其中，T非空， 1<=pos<=StrLen(S)
int Index(SString S, SString T, int pos)
{
	i=pos; 
	j = 1;

	while(i <= S[0] && j <= T[0])
	{
		if(S[i] == T[j]
		{
			++i;
			++j;
		}
		else{
			i = i - j + 2;		//指针后退重新开始匹配
			j = 1;
		}
	}

	if(j > T[0])
		return i-T[0];
	else
		return 0;
}
{% endhighlight %}
在上面算法中，分别利用计数指针```i```和```j```指示主串S和模式串T中当前正待比较的字符位置。算法的基本思想是： 从主串S的第pos个字符起和模式的第一个字符比较之，若相等，则继续逐个比较后续字符； 否则从主串的下一个字符起再重新和模式的字符比较之。依次类推，直至模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则称**匹配成功**，函数值为和模式T中第一个字符相等的字符在主串S中的序号，否则称**匹配不成功**，函数值为0。下图展示了模式T='abcac'和主串S的匹配过程(pos=1)。

{% highlight string %}
               ↓i=3
第一趟匹配  a b a b c a b c a c b a b
           a b c
               ↑j=3


             ↓i=2
第二趟匹配  a b a b c a b c a c b a b
             a
             ↑j=1


                       ↓i=7
第三趟匹配  a b a b c a b c a c b a b
               a b c a c
                       ↑j=5



                 ↓i=4
第四趟匹配  a b a b c a b c a c b a b
                 a 
                 ↑j=1


                   ↓i=5
第五趟匹配  a b a b c a b c a c b a b
                   a 
                   ↑j=1


                               ↓i=11
第六趟匹配  a b a b c a b c a c b a b
                     a b c a c
                               ↑j=1
{% endhighlight %}
上述算法的匹配过程易于理解，且在某些应用场合，如文本编辑等，效率也较高，例如，在检查模式'STING'是否存在于下列主串中时：

'A S**TR**ING S**E**ARCHING EXAMPLE CONS**I**STING of SIMPLE TEXT'

上述算法中while循环次数（即进行单个字符比较的次数）为41，恰好为(Index + T[0]-1)+4, 这就是说，除了主串中呈黑色体的4个字符，每个字符比较了两次以外，其他字符均只和模式进行一次比较。在这种情况下，此算法的时间复杂度为```O(n+m)```。其中，n和m分别为主串和模式的长度。然而，在有些情况下，该算法的效率却很低。例如，当模式串为'00000001',而主串为'00000000000000000000000000000000000000000000000000001'时，由于模式中前7个字符均为'0'，主串中前52个字符均为0，每趟比较都在模式的最后一个字符出现不等，此时需将指针i回溯到i-6的位置上，并从模式的第一个字符开始重新比较，这个匹配过程中指针i需回溯45次，则while循环次数为46*8(index*m)。可见，上述算法在最坏情况下的时间复杂度为O(n*m)。这种情况在只有0、 1两种字符的文本串处理中经常出现，因为在主串中可能存在多个和模式串“部分匹配”的子串，因而引起指针i的多次回溯。```01串```可以用在许多应用之中。比如一些计算机的图形显示就是把画面表示为一个01串，一页书就是一个几百万个0和1组成的串。在二进位计算机上实际处理的都是01串。一个字符的ASCII码也可以看成是8个二进位01串。包括汉字存储在计算机中处理时也是作为一个01串和其他的字符串一样看待。因此下面我们会介绍另一种较好的模式匹配算法。

## 2. 模式匹配的一种改进算法



<br />
<br />

**[参考]**

1. [字符串模式匹配算法1 - BF和KMP算法](https://www.cnblogs.com/zzqcn/p/3508442.html)

<br />
<br />


