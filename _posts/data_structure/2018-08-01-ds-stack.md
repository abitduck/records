---
layout: post
title: 栈的使用
tags:
- data-structure
categories: data-structure
description: 内部排序
---

本章我们主要介绍一下栈的使用。


<!-- more -->


## 1. 表达式求值

### 1.1 求值过程描述
表达式求值是程序设计语言编译中的一个最基本问题。它的实现是栈应用的又一个典型例子。这里介绍一种简单直观、广为使用的算法，通常称为```算符优先法```。

要把一个表达式翻译成正确求值的一个机器指令序列，或者直接对表达式求值，首先要能够正确解释表达式。例如，要对下面的算术表达式求值：
<pre>
4+2x3-10/5
</pre>
首先要了解算术四则运算的规则。即：

1) 先乘除，后加减

2) 从左算到右

3) 先括号内，后括号外

由此，这个算术表达式的计算顺序应为：
<pre>
4+2x3-10/5 = 4+6-10/5 = 10-10/5 = 10-2 = 8
</pre>
算符优先法就是根据这个运算优先关系的规定来实现对表达式的编译或解释执行的。

任何一个表达式都是由```操作数```(operand)、```运算符```(operator)和```界限符```(delimiter)组成的，我们称它们为单词。一般地，操作数既可以是常数也可以是被说明为变量或常量的标识符；运算符可以分为```算术运算符```、```关系运算符```和```逻辑运算符```3类；基本界限符有左右括号和表达式结束符等。为了叙述简洁，我们仅讨论简单算术表达式的求值问题。这种表达式只含加、减、称、除4种运算符。


我们把```运算符```和```界限符```统称为算符，它们构成的集合命名为```OP```。根据上述```3条```运算规则，在运算的每一步中，任意两个相继出现的算符```θ1```和```θ2```之间的优先关系至多是下面3种关系之一：

* **θ1<θ2**: θ1的优先权低于θ2

* **θ1=θ2**： θ1的优先权等于θ2

* **θ1>θ2**: θ1的优先权高于θ2

下表定义了算符之间的这种优先关系：

![ds-stack-oper-priority](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_stack_oper_priority.jpg)

由```规则3)```，+、-、*和/为θ1的优先性均低于```(```但高于```)```; 由```规则2)```，当θ1=θ2时，令θ1>θ2； ```#```是表达式的结束符。为了算法简洁，在表达式最左边也虚设一个```#```构成整个表达式的一对括号。表中“（” = “）”表示当左右括号相遇时，括号内的运算已经完成。同理，“#” = “#”表示整个表达式求值完毕。“）”与“（”、“#”与“）” 以及 “（”与“#” 之间无优先关系，这是因为表达式中不允许它们相继出现，一旦遇到这种情况，则可以认为出现了语法错误。在下面的讨论中，我们暂假定所有输入的表达式不会出现语法错误。

  
为了实现算符优先算法，可以使用两个工作栈。一个称作```OPTR```，用于寄存运算符；另一个称作```OPND```，用于寄存操作数或运算结果。算法的基本思想是：

1） 首先置操作数栈为空栈，表达式起始符“#”为运算符栈的栈底元素；

2） 依次读入表达式中每个字符，若是操作数则进```OPND```栈，若是运算符则和```OPTR```的栈顶运算符比较优先权后作相应操作，直至整个表达式求值完毕（即OPTR的栈顶元素和当前读入的字符均为“#”）

### 1.2 算法实现
如下描述了表达式求值的过程：
{% highlight string %}
//算术表达式求值的算符优先算法。设OPTR和OPND分别为运算符栈和运算数栈， OP为运算符集合
OperandType EvaluateExpression()
{
	InitStack(OPTR);
	Push(OPTR,'#');

	InitStack(OPND);
	
	c = getchar();
	while(c != '#' || GetTop(OPTR) != '#')
	{
		if(!In(c, OP))
		{
			//不是运算符则进栈
			Push(OPND,c);
			c = getchar();
		}
		else{
			switch(Precede(GetTop(OPTR),c))
			{
				case '<':
				{
					//栈顶元素优先权低
					Push(OPTR,c);
					c = getchar();
					break;
				}
				case '=':
				{
					//脱括号，并接收下一字符
					Pop(OPTR,x);
					c = getchar();
					break;
				}
				case '>':
				{
					//退栈并将运算结果入栈
					Pop(OPTR,theta);
					Pop(OPND,b);
					Pop(OPND,a);
					Push(OPND,Operate(a,theta,b));
					break;
				}
			}
		}
	}

	return GetTop(OPND);
}
{% endhighlight %}
上面算法中还调用了两个函数。其中，Precede()函数是判定运算符栈的栈顶运算符```θ1```与读入的运算符```θ2```之间优先关系的函数； Operate()函数为进行二元运算```a θ b```的函数，如果是编译表达式，则产生这个运算的一组相应指令并返回存放结果的中间变量名；如果是解释执行表达式，则直接进行该运算，并返回运算的结果。

### 1.3 运算示例

如下是利用上述算法对算术表达式```3*(7-2)```求值，操作过程如下所示：


## 2. 栈与递归的实现

栈还有


<br />
<br />


