---
layout: post
title: 数据结构之广义表
tags:
- data-structure
categories: data-structure
description: 数据结构之广义表
---

本节我们介绍一下广义表的定义及使用。

<!-- more -->

## 1. 广义表的定义
顾名思义，广义表是线性表的推广，也有人称其为列表(lists，用复数形式以示与统称的表list的区别）。广泛的用于人工智能等领域的表处理语言LISP语言。把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。


抽象数据类型广义表的定义如下：
{% highlight string %}
ADT GList{

数据对象： D={ei | i=1,2,...,n; n>0; ei∈AtomSet 或ei∈GList,
          AtomSet为某个数据对象 }

数据关系： R1={<ei-1,ei> | ei-1,ei∈D, 2<=i<=n}

基本操作：

	InitGList(&L);
	  操作结果： 创建空的广义表L。

	CreateGList(&L, S);
	  初始条件： S是广义表的书写形式串。
	  操作结果： 由S创建广义表L。

	DestroyGList(&L);
	  初始条件： 广义表L存在	
	  操作结果： 销毁广义表L。

	CopyGList(&T, L);
	  初始条件： 广义表L存在
	  操作结果： 由广义表L复制得到广义表T。

	GListLength(L);
	  初始条件： 广义表L存在
	  操作结果： 求广义表L的长度

	GListenDepth(L);
	  初始条件： 广义表L存在
	  操作结果： 求广义表L的深度

	GListEmpty(L);
	  初始条件： 广义表L存在
	  操作结果： 判定广义表L是否为空

	GetHead(L);
	  初始条件： 广义表L存在
	  操作结果： 取广义表L的头

	GetTail(L);
	  初始条件： 广义表L存在
	  操作结果： 取广义表L的尾

	InsertFirst_GL(&L, e);
	  初始条件： 广义表L存在
	  操作结果： 插入元素e作为广义表L的第一元素

	DeleteFirst_GL(&L, &e);
	  初始条件： 广义表L存在
	  操作结果： 删除广义表L的第一元素，并用e返回其值

	Traverse_GL(L, Visit());
	  初始条件： 广义表L存在
	  操作结果： 遍历广义表L，用函数Visit处理每个元素
}ADT GList;
{% endhighlight %}

广义表一般记作：
{% highlight string %}
LS = (α1, α2, ..., αn)
{% endhighlight %}
其中，LS是广义表(α1, α2, ..., αn)的名称，n是它的长度。在线性表的定义中， ai(1≤i≤n)只限于是单个元素。而在广义表的定义中，αi可以是单个元素，也可以是广义表，分别称为广义表LS的```原子```和```子表```。习惯上，用大写字母表示广义表的名称，用小写字母表示原子。当广义表LS非空时，称第一个元素α1为LS的```表头```(Head)，称其余元素组成的表(α2, α3, ..., αn)是LS的表尾(Tail)。

显然，广义表的定义是一个递归的定义，因为在描述广义表时又用到了广义表的概念。下面举一些广义表的例子。
<pre>
(1) A = ()  -------  A是一个空表，它的长度为零

(2) B = (e) -------  列表B只有一个原子e，B的长度为1

(3) C = (a, (b, c, d)) -------  列表C的长度为2，两个元素分别为原子a和子表(b,c,d)

(4) D = (A, B, C) --------  列表D的长度为3， 其3个元素都是列表。显然，将子表的值代入后，择优D=((),(e), (a,(b,c,d)))

(5) E = (α, E) -------  这是一个递归的表，它的长度为2。 E相当于一个无限的列表E=(α, (α, (α, ...))) 
</pre>

从上述的定义和例子可推出列表的3个重要结论：

1） 列表的元素可以是子表，而子表的元素还可以是子表......由此，列表是一个多层次的结构，可以用图形象地表示。例如图5.7表示的列表D。图中以圆圈表示列表，以方块表示原子。

![ds-glist-reps](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_glist_reps.jpg)

2) 列表可为其他列表所共享。例如，在上述例子中，列表A、B、C为D的子表，则在D中可以不必列出子表的值，而是通过子表的名称来引用。

3) 列表可以是一个递归的表，即列表也可以是其本身的一个子表。例如，列表E就是一个递归的表。

根据前述对表头、表尾的定义可知： 任何一个非空列表其表头可能是原子，也可能是列表，而其表尾必定为列表。例如：
<pre>
GetHead(B) = e,    GetTail(B) = ()

GetHead(D) = A,    GetTail(D) = (B, C)
</pre>
由于B、C为非空列表，则可以继续分解得到：
<pre>
GetHead((B, C)) = B, GetTail((B, C)) = (C)
</pre>
值得提醒的是列表```()```和```(())```不同。前者为空表，长度n=0；后者长度n=1，可分解得到其表头、表尾均为空表()。

## 2. 广义表的存储结构
由于广义表(α1, α2, ..., αn)中的数据元素可以具有不同的结构（或是原子，或是列表），因此难以用顺序存储结构表示，通常采用链式存储结构，每个数据元素可用一个结点表示。

如何设定结点的结构？由于列表中的数据元素可能为原子或列表，	由此需要两种结构的结点： 一种是表结点，用于表示列表；一种是原子结点，用以表示原子。从上节得知，若列表不空，则可分解成表头和表尾；反之，一对确定的表头和表尾可唯一确定列表。由此，一个表结点可由3个域组成： 标志域、指示表头的指针域和指示表尾的指针域； 而原子结点只需两个域： 标志域和值域（如图5.8所示）。

![ds-glist-node](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_glist_node.jpg)


其形式定义说明如下：
{% highlight string %}
//------ 广义表的头尾链表存储表示 -------

typedef enum{
	ATOM,          //ATOM == 0: 原子
	LIST           //LIST == 1: 子表
}ElemTag;

typedef GLNode{
	ElemTag tag;                     //公共部分，用于区分原子结点和表结点
	
	union{                           //原子结点和表结点的联合部分
		AtomType atom;               //atom是原子结点的值域，AtomType由用户定义
		struct{
			struct GLNode *hp;
			struct GLNode *tp;
		}ptr;                        //ptr是表节点的指针域，ptr.hp和ptr.tp分别指向表头和表尾
	}
}*GList;                             //广义表类型
{% endhighlight %}
上节中曾列举了广义表的例子，它们的存储结构如图5.9所示。

![ds-glist-eg](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_glist_eg.jpg)

在这种存储结构中有几种情况：

1） 除空表的表头指针为空外，对任何非空列表，其表头指针均指向一个表结点，且该结点中的```hp```域指示列表表头（或为原子结点，或为表结点)，```tp```域指向列表表尾（除非表尾为空，则指针为空，否则必为表结点）；

2）容易分清列表中原子和子表所在层次。如在列表D中，原子a和e在同一层次上，而b、c和d在同一层次且比a和e低一层， B和C是同一层的子表;

3) 最高层的表节点个数即为列表的长度。

以上3个特点在某种程度上给列表的操作带来方便。也可采用另一种节点结构的链表表示列表，如图5.10和图5.11所示。其形式定义说明如下：
{% highlight string %}
//------ 广义表的扩展线性链表存储表示 -------

typedef enum{
	ATOM,          //ATOM == 0: 原子
	LIST           //LIST == 1: 子表
}ElemTag;

typedef GLNode{
	ElemTag tag;                     //公共部分，用于区分原子结点和表结点
	
	union{                           //原子结点和表结点的联合部分
		AtomType atom;               //atom是原子结点的值域，AtomType由用户定义
		
		struct GLNode *hp;           //表结点的表头指针
	};
	
	struct GLNode *tp;               //相当于线性链表的next，指向下一个元素结点
}*GList;    
{% endhighlight %}
对于列表的这两种存储结构，读者只要根据自己的习惯掌握其中一种结构即可。

![ds-glist-another](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_glist_another.jpg)



<br />
<br />
**[参看]:**





<br />
<br />
<br />


