---
layout: post
title: 内部排序（下）
tags:
- data-structure
categories: data-structure
description: 内部排序
---

本节我们介绍一下```归并排序```和```基数排序```。


<!-- more -->


## 1. 归并排序

归并排序（Merging Sort)是又一类不同的排序方法。```归并```的含义是将两个或两个以上的有序表组合成一个新的有序表。它的实现方法早已为读者所熟悉，无论是顺序存储结构还是链表存储结构，都可以在```O(m+n)```的时间量级上实现。利用归并的思想容易实现排序。假设初始序列含有```n```个记录，则可看成是```n```个有序的子序列，每个子序列的长度为1，然后两两归并，得到```⌈n/2⌉```个长度为2或1的有序子序列；再两两归并，.....，如此重复，直至得到一个长度为```n```的有序序列为止，这种排序方法称为```2-路```归并排序。如下图所示为```2-路```归并排序的一个例子：

![ds-merge-sort](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_merge_sort.jpg)

```2-路```归并排序的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列，其算法如下所示：
{% highlight string %}
//将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]
void Merge(RcdType *SR, RcdType *TR, int i,int m, int n)
{
	for(j=m+1, k=i; i<=m && j<=n; ++k)
	{
		if(LQ(SR[i].key, SR[j].key))
			TR[k] = SR[i++];
		else
			TR[k] = SR[j++];
	}
	
	//将剩余的SR[i..m]复制到TR
	if(i<=m)
		TR[k..n] = SR[i..m];

	//将剩余的SR[j..n]复制到TR
	if(j<=n)
		TR[k..n] = SR[j..n]
}
{% endhighlight %}

一趟归并排序的操作是，调用```⌈n/(2h)⌉```次算法merge将SR[1..n]中前后相邻且长度为h的有序段进行两两归并，得到前后相邻、长度为2h的有序段，并存放在TR[1..n]中，整个归并排序需进行```⌈log2^n⌉```趟。可见，实现归并排序需和待排记录等数量的辅助空间，其时间复杂度为```O(nlogn)```。

递归形式的```2-路```归并排序的算法如下所示：
{% highlight string %}
//将SR[s..t]归并排序为TR1[s..t]
void MSort(RcdType *SR, RcdType *TR1, int s,int t)
{
	if(s == n)
		TR1[s] = SR[s];
	else{
		//将SR[s..t]平分为SR[s..m]和SR[m+1,t]
		m = (s + t)>>1;
		MSort(SR, TR2, s,m);
		MSort(SR, TR2, m+1, t);
		Merge(TR2, TR1,s,m,t);
	}
}

void MergeSort(SqList *L)
{
	MSort(L->r, L->r, 1, L->length);
}
{% endhighlight %}
值得提醒的是，```递归形式```的算法在形式上较简洁，但实用性很差。与```快速排序```相比,归并排序的最大特点是： 它是一种稳定的排序方法。一般情况下，很少利用```2-路```归并排序算法进行内部排序。


## 2. 基数排序
```基数排序```(Radix Sorting)是和前面所述各类排序方法完全不相同的一种排序方法。从前面的讨论可见，实现排序主要是通过关键字间的比较和移动记录这两种操作，而实现基数排序不需要进行记录关键字间的比较。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。


### 2.1 多关键字的排序

什么是多关键字排序问题？ 先看一个具体的例子。

已知扑克牌中52张牌面的次序关系为：

![ds-multikey-sort](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_multikey_sort.jpg)
每一张牌有两个```关键字```: 花色( 梅花 < 方块 < 红桃 < 黑桃)和面值(2<3<...<A)，且```花色```的地位高于```面值```，在比较任意两张牌面的大小时，必须先比较```花色```，若花色相同，则再比较面值。由此，将扑克牌整理成如上所述次序关系时，通常采用的办法是： 先按不同花色分成有次序的4堆，每一堆的牌均具有相同的```花色```, 然后分别对每一堆按```面值```大小整理有序。

也可采用另一种办法： 先按不同```面值```分成13堆，然后将这13堆牌自小至大叠在一起（```3```在```2```之上，```4```在```3```之上，...，最上面的4张```A```)，然后将这副牌整个颠倒过来再重新按不同```花色```分成4堆，最后将这4堆牌按自小至大的次序合在一起（```梅花```在最小面，```黑桃```在最上面）， 此时同样得到一副满足如上次序关系的牌。这两种整理扑克牌的方法便是两种多关键字的排序方法。

一般情况下，假设有```n```个记录的序列：
<pre>
{R1,R2, ..., Rn}
</pre>


<br />
<br />


