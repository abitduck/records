---
layout: post
title: 内部排序（下）
tags:
- data-structure
categories: data-structure
description: 内部排序
---

本节我们介绍一下```归并排序```和```基数排序```。


<!-- more -->


## 1. 归并排序

归并排序（Merging Sort)是又一类不同的排序方法。```归并```的含义是将两个或两个以上的有序表组合成一个新的有序表。它的实现方法早已为读者所熟悉，无论是顺序存储结构还是链表存储结构，都可以在```O(m+n)```的时间量级上实现。利用归并的思想容易实现排序。假设初始序列含有```n```个记录，则可看成是```n```个有序的子序列，每个子序列的长度为1，然后两两归并，得到```⌈n/2⌉```个长度为2或1的有序子序列；再两两归并，.....，如此重复，直至得到一个长度为```n```的有序序列为止，这种排序方法称为```2-路```归并排序。如下图所示为```2-路```归并排序的一个例子：

![ds-merge-sort](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_merge_sort.jpg)

```2-路```归并排序的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列，其算法如下所示：
{% highlight string %}
//将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]
void Merge(RcdType *SR, RcdType *TR, int i,int m, int n)
{
	for(j=m+1, k=i; i<=m && j<=n; ++k)
	{
		if(LQ(SR[i].key, SR[j].key))
			TR[k] = SR[i++];
		else
			TR[k] = SR[j++];
	}
	
	//将剩余的SR[i..m]复制到TR
	if(i<=m)
		TR[k..n] = SR[i..m];

	//将剩余的SR[j..n]复制到TR
	if(j<=n)
		TR[k..n] = SR[j..n]
}
{% endhighlight %}

一趟归并排序的操作是，调用```⌈n/(2h)⌉```次算法merge将SR[1..n]中前后相邻且长度为h的有序段进行两两归并，得到前后相邻、长度为2h的有序段，并存放在TR[1..n]中，整个归并排序需进行```⌈log2^n⌉```趟。可见，实现归并排序需和待排记录等数量的辅助空间，其时间复杂度为```O(nlogn)```。

递归形式的```2-路```归并排序的算法如下所示：
{% highlight string %}
//将SR[s..t]归并排序为TR1[s..t]
void MSort(RcdType *SR, RcdType *TR1, int s,int t)
{
	if(s == n)
		TR1[s] = SR[s];
	else{
		//将SR[s..t]平分为SR[s..m]和SR[m+1,t]
		m = (s + t)>>1;
		MSort(SR, TR2, s,m);
		MSort(SR, TR2, m+1, t);
		Merge(TR2, TR1,s,m,t);
	}
}

void MergeSort(SqList *L)
{
	MSort(L->r, L->r, 1, L->length);
}
{% endhighlight %}
值得提醒的是，```递归形式```的算法在形式上较简洁，但实用性很差。与```快速排序```相比,归并排序的最大特点是： 它是一种稳定的排序方法。一般情况下，很少利用```2-路```归并排序算法进行内部排序。


## 2. 基数排序
```基数排序```(Radix Sorting)是和前面所述各类排序方法完全不相同的一种排序方法。从前面的讨论可见，实现排序主要是通过关键字间的比较和移动记录这两种操作，而实现基数排序不需要进行记录关键字间的比较。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。


### 2.1 多关键字的排序

什么是多关键字排序问题？ 先看一个具体的例子。

已知扑克牌中52张牌面的次序关系为：

![ds-multikey-sort](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_multikey_sort.jpg)
每一张牌有两个```关键字```: **花色**( 梅花 < 方块 < 红桃 < 黑桃) 和 **面值**(2<3<...<A)，且```花色```的地位高于```面值```，在比较任意两张牌面的大小时，必须先比较```花色```，若花色相同，则再比较面值。由此，将扑克牌整理成如上所述次序关系时，通常采用的办法是： 先按不同花色分成有次序的4堆，每一堆的牌均具有相同的```花色```, 然后分别对每一堆按```面值```大小整理有序。

也可采用另一种办法： 先按不同```面值```分成13堆，然后将这13堆牌自小至大叠在一起（```3```在```2```之上，```4```在```3```之上，...，最上面的4张```A```)，然后将这副牌整个颠倒过来再重新按不同```花色```分成4堆，最后将这4堆牌按自小至大的次序合在一起（```梅花```在最小面，```黑桃```在最上面）， 此时同样得到一副满足如上次序关系的牌。这两种整理扑克牌的方法便是两种多关键字的排序方法。

一般情况下，假设有```n```个记录的序列：
<pre>
{R1,R2, ..., Rn}       (10-10)
</pre>

![ds-multikey-sort2](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_multikey_sort2.jpg)

```MSD```和```LSD```只约定按什么样的```关键字次序```来进行排序，而未规定对每个关键字进行排序时所用的方法。但从上面所述可以看出这两种排序方法的不同特点： 若按MSD进行排序，必须将序列逐层分割成若干子序列，然后对各子序列分别进行排序；而按LSD进行排序时，不必分成子序列，对每个关键字都是整个序列参加排序，但对```K_i```(0<=i<=d-2)进行排序时，只能用稳定的排序方法。另一方面，按LSD进行排序时，在一定条件下（即对前一个关键字K_i(0<=i<=d-2)的不同值，后一个关键字```K_i+1```均取相同值），也可以不利用前面章节介绍的各种通过关键字间的比较来实现排序的方法，而是通过若干次```分配```和```收集```来实现排序，如上述第二种整理扑克牌的方法那样。



### 2.2 链式基数排序
基数排序是借助```分配```和```收集```两种操作对单逻辑关键字进行排序的一种**内部**排序方法。

有的逻辑关键字可以看成由若干个关键字复合而成的。例如，若关键字是数值，其其值都在```0<=K<=999```范围内，则可把每一个十进制数看成一个关键字，即可认为K由3个关键字(K_0, K_1,K_2)组成，其中```K_0```是百位数， ```K_1```是十位数， ```K_2```是个位数； 又若关键字是由5个字母组成的单词，则可看成是由5个关键字(K_0, K_1, K_2, K_3, K_4)组成。由于如此分解而得到的每个关键字```K_j```都在相同的范围内(对于数字： 0<=K_j<=9； 对于字母： 'A'<=K_j<='Z')，则按LSD进行排序更为方便，只要从最低数位关键字起，按关键字的不同值将序列中记录```分配```到```RADIX```个队列中后再```收集```之， 如此重复d次。按这种方法实现排序称之为```基数排序```，其中```基```值得是RADIX的取值范围，在上述两种关键字的情况下，它们分别是10和26。


实际上，早在计算机出现之前，利用卡片分类机对穿孔卡上的记录进行排序就是用的这种方法。然而，在计算机出现之后却长期得不到应用，原因是所需的辅助存储量(RADIX * N个记录空间）太大。直到1954年有人提出用```计数```代替```分配```才使基数排序得以在计算机上实现，但此时仍需要n个记录和2*RADIX个计数单元的辅助空间。此后，有人提出用链表作存储结构，则又省去了n个记录的辅助空间。下面我们就来介绍这种```链式基数排序```方法。

先看一个具体的例子。首先以静态链表存储```n```个待排记录，并令表头指针指向第一个记录，如下图(a)所示；第一趟分配对最低数位关键字（个位数）进行，改变记录的指针值将链表中的记录分配至10个链队列中去，每个队列中的记录关键字的个位数相等，如下图(b)所示，其中```f[i]```和```e[i]```分别为第i个队列的头指针和尾指针；第一趟收集是改变所有非空队列的队尾记录的指针域，令其指向下一个非空队列的对头记录，重新将10个队列中的记录链成一个链表，如下图(c)所示：


![ds-radix-sort](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_radix_sort.jpg)


第二趟分配，第二趟收集及第三趟分配和第三趟收集分别是对十位数和百位数进行的，其过程和个位数相同，如下图(d)~(g)所示。至此，排序完毕。

![ds-radix-sort2](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_radix_sort2.jpg)
















<br />
<br />


