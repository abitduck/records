---
layout: post
title: AVL树原理及实现（二）
tags:
- data-structure
categories: data-structure
description: AVL树原理及实现（二）
---

我们在上一章中已经介绍了AVL树的原理及实现，在这一章我们再通过一个例子来加深对AVL树的理解。


<!-- more -->


## 1. AVL树的构造

前面我们已经讲述过了AVL树的定义及相关性质，关于如何构造二叉排序树， 我们这里再给出一个例子。参看如下图：

![avl-construct-example](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_avl_construct_example.jpg)


假设表中关键字序列为(13,24,37,90,53)。空树和1个节点```13```的树显然都是平衡的二叉树。在插入24之后仍是平衡的，只是根节点的平衡因子```BF```由0变为-1；在继续插入37之后，由于```节点13```的BF值由-1变成-2，由此出现了不平衡的现象。此时好比一根扁担出现一头重一头轻的现象，若能将扁担的支撑点由```13```改至```24```，扁担的两头就平衡了。由此，可以对树作一个向左逆时针“旋转”的操作， 令```节点24```为根，而```节点13```为它的左子树，此时， ```节点13```和```节点14```的平衡因子都为0， 而且保持二叉排序树的特性。在继续插入90和53之后，由于```节点37```的BF值由-1变成-2，排序树中出现了新的不平衡现象，需进行调整。但此时由于```节点53```插在```节点90```的左子树上，因此不能如上作简单调整。对于以```节点37```为根的子树来说，既要保持二叉排序树的特性，又要平衡，则必须以```节点53```作为根节点，而使```节点37```成为它的左子树的根，```节点90```成为它的右子树的根。这好比对树作了两次“旋转”操作———先向右顺时钟，后向左逆时钟（见上图(f)~(h))， 使二叉排序树由不平衡转化为平衡。

一般情况下，假设由于二叉排序树上插入节点而失去平衡的最小子树根节点的指针为```x```(即 x 是离插入节点最近， 且平衡因子绝对值超过1的祖先节点），则失去平衡后进行调整的规律可归纳为下列4种情况：

**(1) 情形1**

单向右旋平衡处理： 由于在```*x```的左子树根节点的左子树上插入节点，```*x```的平衡因子由1增至2， 致使以```*a```为根的子树失去平衡，则需进行一次向右的顺时针旋转操作。 此种情形就是所谓的```LL型```。

![ds-avl-right-rotate](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_avl_right_rotate.jpg)

**(2) 情形2**

单向左旋平衡处理： 由于在```*x```的右子树根节点的右子树上插入节点， ```*x```的平衡因子由-1变为-2，致使以```*x```为根节点的子树失去平衡，则需进行一次向左的逆时钟旋转操作。此种情形就是所谓的```RR型```。

![ds-avl-left-rotate](https://ivanzz1001.github.io/records/assets/img/data_structure/ds_avl_left_rotate.jpg)





<br />
<br />
**[参看]:**

1. [AVL树原理及实现](http://www.cnblogs.com/nullzx/p/6075644.html)

2. [AVL树](https://baike.baidu.com/item/AVL%E6%A0%91/10986648?fr=aladdin)

<br />
<br />
<br />


