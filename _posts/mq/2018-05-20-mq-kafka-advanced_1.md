---
layout: post
title: kafka进阶
tags:
- mq
categories: mq
description: kafka进阶
---

前面我们对于kafka的介绍主要还是偏向于使用操作层面，这里作为kafka进阶的第一篇，我们讲述一下kafka若干方面的设计原理。



<!-- more -->

## 1. kafka设计动机
我们设计kafka的主要目的是为了能够有一个统一的平台(platform)来处理各种大规模的实时流数据。为了实现这一目标，我们在设计时可能就得考虑各种用例场景:

* kafka必须拥有高吞吐率，以支持大量的实时流数据，例如日志集

* kafka需要能够优雅的处理大量的日志数据，以支持某一时刻数据从离线系统进行加载

* kafka在处理消息时必须具备低延迟

因此，我们希望创建的kafka能够支持分区(partitioned)、分布式(distributed)、实时(real time)的来处理输入的数据，然后产生新的输出。这就是kafka的```分区模型```(partitioning model)以及```消费模型```(consumer model)的设计由来。

最后，由于输入到kafka中的数据流所产生的输出可能还需要提供给其他系统使用，因此系统必须要能够保证高容错性以应对机器可能出现的宕机情况。


为了实现上述这样一些目标，我们就得考虑方方面面，而不仅仅是在传统消息系统层面加上一个database log。

## 2. 持久化

### 2.1 不要畏惧文件系统
kafka严重依赖文件系统来存储和缓存消息，而我们通常有一个观念会认为“磁盘是低速的”，因此就会怀疑使用磁盘来存储数据到底能不能够达到一个有竞争力的性能指标。实际上，在使用磁盘时主要取决于使用者的期望，如果我们期望很高，则磁盘可能确实是一个很低速的设备，反之则其实磁盘性能也未必有那么差。如果我们适当的设计数据在磁盘上的存储结构，则很可能能够获得与网络(network)相同数量级的速度。

在过去十年，有关磁盘性能的关键事实是，硬盘驱动器的吞吐量与磁盘寻道的延迟时间是不相同的。如果我们在一个JBOD配置，转速为7200rpm的SATA RAID-5磁盘矩阵上进行连续写入的话，每秒钟的写入速度可以达到600MB；而如果我们采用随机写的话，则每秒钟的写入速度可能只有100KB，这两者之间相差了6000倍。在所有的使用模式当中，线性的读、写操作均是最优的，并且得到了操作系统的深度优化。现代操作系统通常都提供了预读(pre-read)技术来处理大块数据读取，也提供了延迟写(write-behind)技术来将将多个逻辑写操作合并成一个物理写操作。


为了弥补磁盘性能方面的不足，现代操作系统开始大量使用内存来为磁盘做缓存。现代OS通常都倾向于使用大量空闲内存空间来作为磁盘缓存，而当内存需要收回时，对性能的损耗也是微乎其微的。磁盘所有的读写操作都会通过操作系统这一统一的缓存来进行。该特性（通过操作系统缓冲读写磁盘文件）通常很难被关闭，除非使用direct IO，因此即使一个进程在进程内维持着自己的一份数据缓存，该数据也会在OS pagecache再缓存一次，这样就可能会导致缓存两次。

更重要的是，因为Kafka是构建在JVM之上的，所有了解Java内存使用的人都应该知道：

* 所占用的内存通常会大大超出Java objects的大小，很多时候会超过其2倍，甚至更多

* 随着堆(heap)中对象数据的增加，java垃圾回收会开始变的低速

正是由于上面这些原因，我们更倾向于使用文件系统和操作系统的pagecache，而不是自己在进程中维持一份缓存———这样至少增加了操作系统可用缓存。因此，在一个32GB内存的系统上就可以有多达28~30GB的空间来作为cache。更为重要的是，即使服务(service)重启，这份缓存可能仍然可以使用，而应用程序内的缓存则需要进行重建。同时，采用操作系统缓存也可以大大简化代码的编写，而不必担心缓存与文件系统之间数据的一致性逻辑。假如我们的读操作大部分都是线性读的话，则预读取(read-ahead)通常可以很好的预先把我们要从磁盘读取的数据先加载到cache中。

### 2.2 常数时间读







<pre>
</pre>



<br />
<br />

**[参考]**



1. [kafka官网](https://kafka.apache.org/)

2. [历史性难题——如何为Kafka挑选合适的分区数？](https://www.jianshu.com/p/fa7a65febcc0)


<br />
<br />
<br />

