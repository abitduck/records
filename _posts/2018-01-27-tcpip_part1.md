---
layout: post
title: tcpip半关闭状态
tags:
- tcpip
categories: tcpip
description: tcpip半关闭状态
---


本章我们主要讲述一下tcpip半关闭状态及可能产生的问题。


<!-- more -->

## 1. shutdown函数介绍


## 2. 测试示例

### 2.1 server.c源代码
{% highlight string %}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <signal.h>
#include <string.h>


static void sig_handler(int sig)
{
   if(sig == SIGPIPE)
   {
        write(1,"server recv SIGPIPE\n",sizeof("server recv SIGPIPE\n"));
   }
}

int main(int argc,char *argv[])
{
   int fd = -1,clientfd = -1;
   struct sockaddr_in servAddr,clientAddr;
   int len,clientAddrLen;
   char buf[128];

   signal(SIGPIPE,sig_handler);


   fd = socket(AF_INET,SOCK_STREAM,0);
   if(fd < 0)
   {
      printf("create socket failure\n");
      exit(-1);
   }

   memset(&servAddr,0x0,sizeof(struct sockaddr_in));
   servAddr.sin_family = AF_INET;
   servAddr.sin_addr.s_addr = INADDR_ANY;
   servAddr.sin_port = htons(8010);   

   if(bind(fd,(struct sockaddr *)&servAddr,sizeof(struct sockaddr_in)) < 0)
   {
      printf("bind addr failure\n");
      exit(-1);
   }

   listen(fd,5);

   clientAddrLen = sizeof(struct sockaddr_in);
   clientfd = accept(fd,(struct sockaddr *)&clientAddr,&clientAddrLen);
      
   len = send(clientfd,"welcome to my server",sizeof("welcome to my server")-1,0);

   while((len = recv(clientfd,buf,128-1,0)) > 0)
   {
       buf[len] = 0;
       if(strcmp(buf,"SHUT_RD") == 0)
       {
          printf("SHUT_RD operation\n");

          shutdown(clientfd,SHUT_RD);
          send(clientfd,"recv SHUT_RD",sizeof("recv SHUT_RD")-1,0);
       }
       else if(strcmp(buf,"SHUT_WR") == 0)
       {
          printf("SHUT_WR operation\n");

          shutdown(clientfd,SHUT_WR);
          send(clientfd,"recv SHUT_WR",sizeof("recv SHUT_WR")-1,0);          
       }
       else if(strcmp(buf,"SHUT_RDWR") == 0)
       {
          printf("SHUT_RDWR operation\n");
          
          shutdown(clientfd,SHUT_RDWR);
          send(clientfd,"recv SHUT_RDWR",sizeof("recv SHUT_RDWR")-1,0);
       }
       else{
           printf("recv: %s\n",buf);
           send(clientfd,"server: hello,client",sizeof("server: hello,client")-1,0);
       }
   }
   
   printf("quit(len: %d)\n",len);
   if(len == 0)
   {
       while(1)
         sleep(1000);
   }
   return 0x0;
}
{% endhighlight %}

编译：
<pre>
# gcc -o server server.c
</pre>

### 2.2 client.c源代码
{% highlight string %}
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <signal.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <signal.h>
#include <arpa/inet.h>

void signal_handler(int sig)
{
    if(sig == SIGPIPE)
    {
         write(1,"client recv SIGPIPE\n",sizeof("client recv SIGPIPE\n"));
    }
}

static void *thread_proc(void *arg)
{
     char buf[128];
     int sz;
     int fd = (int)arg;
     printf("proc fd: %d\n",fd);

     while(1)
     {
          sz = recv(fd,buf,128-1,0);
          if(sz < 0)
          {
             printf("recv error\n");
             pthread_exit(0);
          }
          else if(sz == 0)
          {
             printf("server closed\n");
             pthread_exit(0);
          }
          else{
             buf[sz] = 0;
             printf("->: %s\n",buf);
          }
     }
}


int main(int argc,char *argv[])
{
     int fd;
     struct sockaddr_in serverAddr;
     char buf[128];
     int sz;
     pthread_t pid;

     signal(SIGPIPE,signal_handler);  

     fd = socket(AF_INET,SOCK_STREAM,0);
     if(fd < 0)
     {
         printf("create socket failure\n");
         exit(-1);
     }

     memset(&serverAddr,0x0,sizeof(struct sockaddr_in));

     serverAddr.sin_family = AF_INET;
     serverAddr.sin_addr.s_addr = inet_addr(argv[1]);
     serverAddr.sin_port = htons(atoi(argv[2]));

     if(connect(fd,(struct sockaddr *)&serverAddr,sizeof(struct sockaddr_in)) < 0)
     {
        printf("connect %s:%s failure\n",argv[1],argv[2]);
        exit(-1);
     }
     
     printf("connect %s:%s successful\n",argv[1],argv[2]);
     
     if(pthread_create(&pid,NULL,thread_proc,(void *)fd) < 0)
     {
         printf("create thread failure\n");
         exit(-2);
     }
     printf("pass fd: %d\n",fd);

     while(1)
     {
         sz = read(0,buf,128);
         if(sz < 0)
         {
             printf("read input error\n");
             break;
         }
         buf[sz-1]=0;    //clear the "\n"

         if(strcmp(buf,"CLOSE_RD") == 0)
         {
             printf("Client close RD\n");
             shutdown(fd,SHUT_RD);
         }
         else if(strcmp(buf,"CLOSE_WR") == 0)
         {
              printf("Client close WR\n");
              shutdown(fd,SHUT_WR);
         }
         else if(strcmp(buf,"CLOSE_RDWR") == 0)
         {
              printf("Client close RDWR\n");
              shutdown(fd,SHUT_RDWR);
         }
         else{
            sz = send(fd,buf,sz,0);
            if(sz < 0)
            {
               printf("send error\n");
               break;
            }
         }
     }
    while(1)
        sleep(1000);
}
{% endhighlight %}
编译：
<pre>
# gcc -o client client.c -lpthread
</pre>


### 2.3 测试
如果某一个socket句柄fd的写关闭:
<pre>
shutdown(fd,SHUT_WR)
</pre>
后续再向该句柄进行写入操作，则会产生```SIGPIPE```信号。向一个读端关闭的socket进行写操作，则写入的数据都会被丢弃。如果进行tcp通信的两方，有一方检测到对端读写都已经关闭（例如：client检测到server已经关闭，但是client本身并未执行关闭操作），此时如果再向对端进行写操作同样会产生```SIGPIPE```信号。








<br />
<br />
<br />

